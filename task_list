PICKED
 * provide custom uint64 and int64 implementation based on large_uint and large_int for competeness
 * make function to convert double to large_uint and large_int using bit shifting, fail if the number is nan or infinity or for large_uint if it is negative, never fail for a (+/-)0.0, and then finally fail if the integer component overflows, implement the large_uint first and then implement large_int version using it
   * write test cases for it
 * make function to convert double_parts back into a double
   * test this by making double parts and back to double again and comparing them with equals
 * make optimized functions to find first and last 1 bit and 0 bits in large_uint and extend it for large_int
 * use the above function to find most significant 1 and shift it 64 bits to make a double_parts and then back again into a double
 * make a function to compare_large_uint_and_double and compare_large_int_and_double, using this bit shifting logic, return error only on a nan, and assume +0.0 and -0.0 are then same

VAR_INT and VAR_UINT
 * build serialize_var_uint64 and deserialize_var_int64, with a layout similar to that of protobuf, to build VAR_INT and VAR_UINT on top of them in TupleIndexer, use get_min_bit_count_uintX/intX functionality to store only that many bits
 * also implement get_byte_count_for_serial_var_int64 and get_byte_count_for_serial_var_uint64, to get number of bytes in their serialized format

make custom float representations
 * float128, float256 and float512 versions, using the int and uint large numbers
 * using unsigned int:2 (sign and infinity) int64_t:(64-2) for exponent and then correspondng uint versions for required precision