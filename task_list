LARGE_UINT refactoring and new features
 * implement shift_left and shift_right function for large_uint
  * large_uint left/right_shift_large_uint(large_uint a, uint32_t s)
  {
    res = ZERO
    from = 0/s
    to = s/0
    while (from < bitwidth && to < bitwidth) {
    	move_one_limb(&res, to, a, from)
		}
		return res;
	}
	* bitwidth of limb = B
  * move_one_limb(large_uint* res, uint32_t to, large_uint a, uint32_t from) {
  	uint64_t m = 0;
  	// read into m
  	m = (a[from/B] >> (from%B));
  	if(from%B)
  		m |= (a[from/B + 1] << (from%B));
  	// write from m
  	res[to/B] |= (m << (to%B));
  	if(to%B)
      res[to/B + 1] |= (m >> (to%B));
  }
 * implement implement multiplication function for large_uint

VAR_INT and VAR_UINT
 * build serialize_var_uint64 and deserialize_var_int64, with a layout similar to that of protobuf, to build VAR_INT and VAR_UINT on top of them in TupleIndexer, use get_min_bit_count_uintX/intX functionality to store only that many bits
 * also implement get_byte_count_for_serial_var_int64 and get_byte_count_for_serial_var_uint64, to get number of bytes in their serialized format
